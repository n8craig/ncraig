{
  "hash": "0c12495309e21c3f0132274807358013",
  "result": {
    "markdown": "---\ntitle: \"Dealing with compound fields\"\nabstract: |\n We have a table containing a compound field that is composed of multiple values separated by a delimeter. Here we are simulating data exported from PastPerfect museum catalog software. There are several such cases one might encounter: material, use, culture, etc.\n\nauthor: \"Nathan Craig\"\ndate: 2022-10-13\ncategories: \n - how-to\n - wrangling\nformat: \n  html:\n    df-print: kable\n---\n\n\nGenerally, it is not a good idea to put multiple values into a single table cell. This is not [tidy](https://cran.r-project.org/web/packages/tidyr/vignettes/tidy-data.html) and it is cumbersome to deal with fields so structured. However, given the constraints of some data entry systems, one may need to encode compound values to describe the observation. Suppose an individual is recording an object made of three materials but the data entry form only offers a single field (@fig-pp-input). We don't want to log just one value; we would rather capture all three materials. When confronted with such situations, people often enter some kind of delimited value like `apple/pear/orange` where `/` is the separator for three values. What follows is a way of dealing with this situation in R.\n\n![Past Perfect input screen with compound fields highlighted in red.](https://i.imgur.com/27byU9G.png){#fig-pp-input}\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load libraries\nlibrary(tidyverse)\nlibrary(stringi)\n```\n:::\n\n::: {#tbl-make-df .cell tbl-cap='Sample dataframe.'}\n\n```{.r .cell-code}\n# Construct data frame\ndf <- data.frame(\n  id = 1:5,\n  material = c(\n    \"stone\",\n    \"stone/bone/sinew\",\n    \"ceramic/paint\",\n    \"metal/stone/bone/sinew/paint\",\n    NA\n  ),\n  location = \"NM\"\n)\n\ndf\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| id|material                     |location |\n|--:|:----------------------------|:--------|\n|  1|stone                        |NM       |\n|  2|stone/bone/sinew             |NM       |\n|  3|ceramic/paint                |NM       |\n|  4|metal/stone/bone/sinew/paint |NM       |\n|  5|NA                           |NM       |\n\n</div>\n:::\n:::\n\n\nNow we have a data frame where material contains entries representing more than one value. With `stringi` R can parse that complex string into a list.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Split the string into a list\ndf$material <- str_split(df$material, \"/\")\n```\n:::\n\n\nIt is possible to access a given list item with `unlist()`. This can be done for individual records, ranges of records, or the entire column.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get the list item from the second record\ndf[2,][,2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] \"stone\" \"bone\"  \"sinew\"\n```\n:::\n\n```{.r .cell-code}\n# Unpack the list associated with that record\nunlist(df[2,][,2])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"stone\" \"bone\"  \"sinew\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Unpack the entire list column as a single list\nx <- unlist(df[,2])\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"stone\"   \"stone\"   \"bone\"    \"sinew\"   \"ceramic\" \"paint\"   \"metal\"  \n [8] \"stone\"   \"bone\"    \"sinew\"   \"paint\"   NA       \n```\n:::\n:::\n\n\nLet's turn the list of all values into its own data frame.\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_x <- tibble(x)\n```\n:::\n\n\nTo see how many of each type of object we have, we can use `tidyverse` verbs to group by and summarize (@tbl-summarise).\n\n\n::: {#tbl-summarise .cell tbl-cap='Counts by value extracted from a compound field.'}\n\n```{.r .cell-code}\ndf_x %>% group_by(x) %>% \n  summarize(n = n())\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|x       |  n|\n|:-------|--:|\n|bone    |  2|\n|ceramic |  1|\n|metal   |  1|\n|paint   |  2|\n|sinew   |  2|\n|stone   |  3|\n|NA      |  1|\n\n</div>\n:::\n:::\n\nLet's search for a specific material and filter the table returning only records that meet the search criteria (@tbl-result).\n\n\n::: {#tbl-result .cell tbl-cap='Primary table filtered based on presence of search string in compound field.'}\n\n```{.r .cell-code}\n# Test for the presence of a string\n# returns a TRUE/FALSE vector\na <- stri_detect_regex(df$material, \"stone\")\n\n# Get the numerical value of the record when TRUE\nb <- which(a == TRUE)\n\n# Call the rows based on the index\ndf[b,]\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|   | id|material                          |location |\n|:--|--:|:---------------------------------|:--------|\n|1  |  1|stone                             |NM       |\n|2  |  2|stone, bone , sinew               |NM       |\n|4  |  4|metal, stone, bone , sinew, paint |NM       |\n\n</div>\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}